## JVM笔记

### 类加载
> 在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的。

> 类型是什么？我们定义的class, interface, enum，java.lang.String等等，并不涉及对象

> 类型的加载最常见的是将编译好的class文件从磁盘上加载到内存当中

> 连接将类与类之间的关系确定好，

> 初始化：对类型里面的一些静态的变量进行赋值

### 类加载器
类加载器是用来加载类型的

Java虚拟机本身就是一个进程，在下面几种情况下就结束生命周期

> 执行了System.exit()方法

> 程序正常执行结束

> 程序在执行过程中遇到了一次或者错误而异常终止（异常一直往外抛，最终达到main方法，main方法再往上抛紧接着程序就退出了）

> 由于操作系统错误而导致Java虚拟机进程终止，这是我们无法控制的

### 类的加载、连接与初始化

**加载**

> 加载：查找并加载类的二进制数据，将class文件加载到内存

**连接**

> 连接: 最为复杂的阶段，又分为3个阶段

> 1.验证：确保被加载的类的正确性

> 2.准备：为类的静态变量分配内存，并将其初始化为默认值，比如整型的默认值是0，boolean类型的默认值是false，引用的默认值是null

> 如：public static int a = 1, 在准备阶段并不会将1赋给a，而是将0赋给a

> 3.解析：把类中的符号引用转换为直接引用，符号引用：方法里面引用了某个类，直接引用：内存地址

**初始化**
> 初始化：为类的静态变量赋予正确的初始值

> 如：将1赋给了a，执行静态代码块

**类的使用与卸载**

> 使用: 比如：创建类的对象，调用类的方法，使用是和我们开发打交道最多的一个过程

> java程序对类(不是对象)的使用方式分为两种

> 1.主动使用

> 2.被动使用

> 所有的Java虚拟机实现必须在每个类或接口被Java程序“**首次主动使用**”时才被初始化他们

首次主动使用说明：

> 被动使用不会初始化他们

> 只会初始化一次

### 主动使用（七种）

> 1.创建类的实例。-> new 出来一个对象

> 2.访问某个类或接口的静态变量，或者对该静态变量赋值。-> 对静态变量赋值(putstatic)和取值(getstatic)

> 3.调用类的静态方法. -> 和第二种情况一样(invokestatic)

> 4.反射(如Class.forName("com.jin.Test"))

> 5.初始化一个类的子类。它的父类也会被初始化

> 6.Java虚拟机启动时被标记为启动类(Java Test)。 包含main方法的那个类

> 7.JDK1.7 开始提供动态语言支持：

> java.lang.invoke.MethodHandle实例的解析结果REF_getStatic, REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化。 了解一下就行


除了以上七种情况，其他使用Java类的方式都被看作是对类的**被动使用**，都不会导致类的**初始化**。

> 不会初始化并不意味着不会去加载，初始化是第三个阶段

### 类的加载

> 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，
> 然后在内存中创建一个java.lang.Class对象(规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中)
> 用来封装类在方法区内的数据结构

说明：
> 一个类无论创建了多少个对象，所有对象所对应的Class对象只有一个。

### 加载.class文件的方式

> 从本地系统中直接加载。绝大多数情况下使用的方式

> 通过网络下载.class文件。

> 从zip, jar等归档文件中加载.class文件。

> 从专有数据库中提取.class文件。

> 将Java源文件动态编译为.class文件。动态代理会使用，jsp转换成的servlet类


### 静态字段

> 对于静态字段来说，只有直接定义了该字段的类才会被初始化；

> 当一个类在初始化时，要求其父类全部都已经初始化完毕了(父类还有父类 都要先初始化)

### 常量

> 常量在编译阶段会存入到调用这个常量的方法所在的类的常量池当中,本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。

>
>




















































































