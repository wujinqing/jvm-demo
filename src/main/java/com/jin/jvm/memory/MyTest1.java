package com.jin.jvm.memory;

/*

    虚拟机栈：Stack Frame 栈帧  方法执行出栈  入栈  局部变量表, 归属于特定线程的是线程私有的一部分内存空间。
    程序计数器：(Program Counter PC) 程序执行位置。线程私有的一部分内存空间。
    本地方法栈：主要用于处理本地方法
    堆(Heap): JVM管理的最大一块内存空间。线程共享的, Java中是通过引用来去操作对象，不能直接操作对象。对象位于堆上面，引用位于虚拟机栈
    (局部变量表里面的一个局部变量)上面。与堆相关的一个重要概念是垃圾收集器。现在几乎所有的垃圾收集器都是采用分代收集算法。所以，堆空间也
    基于这一点进行了相应的划分：新生代和老年代。Eden空间, From Survivor空间与To Survivor空间。


    方法区（Method Area）: 位于堆上，存储元信息，如：常量、静态变量、Class对象。永久代（Permanent Generation）,
    从JDK1.8开始，已经彻底废弃了永久代，使用元空间(meta space)代替。JDK1.8已经没有PerSize等设置了。

    运行时常量池：方法区的一部分内容。编译期就能确定，包括类里面的一些常量，符号引用等。
    直接内存：Direct Memory  并不是有JVM直接管理，而是操作系统管理，与Java NIO密切相关。JVM通过堆上的DirectByteBuffer来操作直接内存。

    可以通过new、 Class对象、序列化、clone的方式创建对象。



    关于Java对象的创建过程：
    new关键字创建对象的3个步骤:
    1.在堆内存中创建出对象的实例（类加载、内存分配、创建对象）。
    2.为对象的实例成员变量赋初值（静态变量已经在初始化阶段赋值了）。
    3.将对象的引用返回。

    指针碰撞: (前提是堆中的空间是通过一个指针进行分割的，一侧是已被占用的空间，另一侧是未被占用的空间)
    空闲列表: (前提是堆内存空间中已被使用的空间与未被使用的空间是交织在一起的，这时，虚拟机就需要通过一个列表来记录哪些空间是可以使用的，
    哪些空间是已被使用的，接下来找出可以容纳下新创建对象的且未被使用的空间，在此空间存放该对象，同时还有修改列表上的记录）

    对象在内存中的布局:

    1.对象头。
    2.实例数据(即我们在一个类中所声明的各项信息, 成员变量信息)。
    3.对齐填充(可选).


    引用访问对象的方式：
    1.使用句柄的方式。
    2.使用直接指针的方式。
 */


import java.util.ArrayList;
import java.util.List;

public class MyTest1 {
    public static void main(String[] args) {
        List<MyTest1> list = new ArrayList<>();

        for(; ;)
        {
            list.add(new MyTest1());
            System.gc();
        }
    }

}
